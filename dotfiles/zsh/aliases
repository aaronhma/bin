# Command Enhancements

#  ===========
#  = Utility =
#  ===========
alias reload='source ~/.zshrc'

alias pip='python3 -m pip'
alias jupyter='python3 -m jupyter'

export computer="Aaron's iMac"

alias oo="open ."
alias o='open . &'
alias safari="open -a safari"
alias chrome="open -a google\ chrome"
alias f='open -a Finder '
alias textedit='open -a TextEdit'
alias preview="open -a '/Applications/preview.app'"

alias desktop='cd ~/Desktop'

#############################
# Easier navigation: .., ..., ...., ....., ~ and -
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ~="cd ~" # `cd` is probably faster to type though
alias p='cd -'  # goto last dir cd'ed from
alias s='cd ..'   # up one dir
# Open current directory in Tree View
if [ ! -x "$(which tree 2>/dev/null)" ]
then
  alias tree="find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'"
fi
# function cr() {  cd ~/repos/$* }   # Quicker cd


# Show list of files or directories
alias l='ls -lhGt'  # -l long listing, most recent first  # -G color
alias la="ls -Gla" # List all files colorized in long format, including dot files
alias ld='ls -l | grep "^d"' # List only directories
alias l.='ls -d .[^.]*'  # List all files starting with .
alias lh="ls -lh"
alias ll='ls -lhasG'  # -l long listing, human readable, no group info
alias lt='ls -lt' # sort with recently modified first

# Go into the name of the directory and list its files
# cdll testFolder
function cdll() {  cd $1; ll  }

# Make a new directiory and go straight into the newly created dir
# dir testFolder
function dir() {  mkdir -p "$@" && cd "$@" }

# Always use color output for `ls`
if [[ "$OSTYPE" =~ ^darwin ]]; then
	alias ls="command ls -G"
else
	alias ls="command ls --color"
	export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'
fi


# Clear the current window
alias c='clear'
alias cll='clear; ll'

alias q='exit'
alias k9="killall -9"
function killnamed () {
	ps ax | grep $1 | cut -d ' ' -f 2 | xargs kill
}

alias h='history | tail'
alias md='mkdir -p'
alias rm='rm -i' #always do interactive rm's

#  ===========
#  = Docker =
#  ===========
# # Show the last container
# alias dpsl="docker ps -a -l"

# alias d="docker "

# # Show the last container id
# alias dpslq="docker ps -a -l -q"

# # Show All Containers
# alias dpsa="docker ps -a"

# # Show All Containers with its container id
# alias dpsaq="docker ps -a -q"

# # Removing All Not-Running Containers
# alias drma="docker rm $(docker ps -a -q)"

# # Removing All Not-Running Containers
# alias drmf="docker kill $(docker ps -q) ; docker rm $(docker ps -a -q)"

# # Removing All Images
# alias drmia="docker rm $(docker ps -a -q) ; docker rmi $(docker images -a -q)"

# # Removing All Containers and All Images (Spring Cleaning)
# alias drmif="docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -a -q)"

# alias dpsip="docker inspect --format '{{.NetworkSettings.IPAddress}}' "


#############################
# Git   http://marklodato.github.com/visual-git-guide/index-en.html
# Git CheatSheet   http://cheat.errtheblog.com/s/git/
# Checkout here https://github.com/jwiegley/git-scripts
#
# Git Log (gl)
# Git Push (gp)
# Git Reset (grs)
# Git Rebase (grb)
# Git Remote (gro)
# Git Show (gsh)
# Git Stash (gst)
# Git Tag (gt)
# Git Submodule (gsm)
# Git Rm (grm)
# Git Format-Patch (gph)

# HEAD pointer: which tells you what commit you're working on
# working tree: which represents the state of the files on your system
# staging area: alias index, which "stages" changes so that they can later be committed together

alias ungit="find . -name '.git' -exec rm -rf {} \;"
# go to the top folder level of the version control files
alias gcd='cd "`git rev-parse --show-toplevel`"'

alias gi='git init'
alias ga='git add'
alias gaa='git add -A'

# Only match already tracked files, never stage new files
# stage all changes in all tracked files, all modifications in all know files will be include in the next commit
alias gau='git add -u'
alias gap='git add -p'  #add lines of code to the next commit

alias gb='git branch'
alias gbv='git branch -v'
alias gba='git branch -a'
alias gbd="git branch -D"   # Deletion
alias gbn='git branch -b'

# Delete all local branches that have been merged into HEAD. Stolen from
# https://plus.google.com/115587336092124934674/posts/dXsagsvLakJ
alias gbdall= git branch -d "git branch --merged | grep -v '^*' | grep -v 'master' | tr -d '\n'"

# Commit pending changes and quote all args as message
alias gc='git commit'  # simply just commit with nessessary message
alias gca='git commit -a'   # auto add all known change files, and commit
alias gcv='git commit -v -a'   # -v for verbose.  Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template.
alias gcm='git commit --amend'  # modify the last commit

# cherry-pick: "copies" a commit, creating a new commit on the current branch with the same message and patch as another commit.
alias gcp='git cherry-pick'

alias gbl="git blame"

alias gco='git checkout'
alias gcob='gco -b'
alias gcop='gco -p'
alias gcoB='gco -B' #gco -B [branch-name] [SHA] create a new branch at a specific SHA. Override any exist branch with same name
alias gcom='git checkout master'

alias g='git status'
alias gg='git status -sb' # upgrade your git if -sb breaks for you. summary of file changes, additions, deletions
#alias grm="git status | grep deleted | awk '{print \$3}' | xargs git rm"

# @{n} reflog reference, value of the HEAD of your repository
# HEAD^   :previous commit, which means "the parent of HEAD"
# d921970^2 means "the second parent of d921970."
# HEAD~ and HEAD^ are equivalent. The other main ancestry specification is the ~. also the first parent .The difference becomes apparent when you specify a number. HEAD~2 means "the first parent of the first parent," or "the grandparent" — it traverses the first parents the number of times you specify.
# HEAD^^^, which again is the first parent of the first parent of the first parent

#  ============
#  = Git Log (gl) =
#  ============
alias gl='git log'  #git log SHA (commit id)
alias glp='gl --patch' #gl --patch [filename]  show history of a single file
#gl -s '.className' search git entire commit history for a word/phrase
# add flag   --stat    --patch for show more info
alias gls='gl -s' # --stat   with stats (files changed, insertions, and deletions)
alias gll='git log -1 HEAD'

#alias glog="git log --pretty='format:%Cgreen%h%Creset %an - %s' --graph"
alias glog="git log --graph --pretty=format:'%C(red)%h%C(reset) %C(dim white)%an%C(reset): %C(cyan)%s - %C(reset) %C(yellow)%d%C(reset) %C(dim white)(%cr)%Creset' --abbrev-commit --date=relative"
alias glog2="git log --graph --abbrev-commit --decorate --format=format:'%C(bold red)%h%C(reset) - %C(bold green)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"

# gl1 foo.txt  // a list of all commits containg foo.txt
alias gl1="git rev-list --all --pretty=format:'%C(red)%h%C(reset) %C(dim white)%an%C(reset): %C(cyan)%s - %C(reset) %C(yellow)%d%C(reset) %C(dim white)(%cr)%Creset' "

alias gla="glog --author " #get specific author's commits

# build on top of alias shortcut, search a Git repository by commit message
# @usage:  glf 'feature name rock'  or  glf feature/css   # take only single param.
alias glf="glog --all --grep"

# To search the actual content of commits through a repo's history
# @usage:  glfc 'var $el = $(e.target)'
alias ggrep='git grep '

alias glr='git reflog'
alias glrh='git reflog show HEAD' # get a history of all of the places HEAD has pointed.

# gem install omglog
# show the commit graph with live updating as commits are made, merged, branched
alias glo='omglog'

# visualizing your repo (https://www.kernel.org/pub/software/scm/git/docs/git-instaweb.html)
# Show your commits in the real browsers
alias glw='git instaweb --httpd webrick'


#  =============
#  = Git Push (gp) =
#  =============
alias gp='git push'
# will abort a push if you have not pushed a submodule
alias gpc='git push --recurse-submodules=check'
# when push parent repo, if submodule need to push, auto push it.
alias gpa='git push --recurse-submodules=on-demand'
alias gpthis='gp origin $(git_current_branch)'

alias gpt='git push --tags'  # transfer all of your tags to the remote server that are not already there.
# By default, the git push command doesn’t transfer tags to remote servers. have to explicitly push tags to a shared server after you have created them. This process is just like sharing remote branches — you can run git push origin [tagname]
alias gpo='git push origin'  # transfer a specific tag   ex: git push origin v1.5

alias gsp='git smart-pull'

#  ==============
#  = Git Reset (grs) =
#  ==============
# Take the current branch and reset it to point somewhere else, and possibly bring the index and work tree along
# reset doesn't make commits, just updates a branch (which is a pointer to a commit)
alias grs='git reset'
# --hard moves HEAD and adjusts your staging area and working tree to the new HEAD, throwing away everything.
# makes everything match the commit you've reset to. always throws aways uncommited changes
alias grsh="git reset --hard"
#alias gundo='git reset --hard HEAD^'  # Undo your last commit
alias grsp='git reset --patch'
# --soft moves HEAD but doesn't touch the staging area or the working tree.
# ex: made some bad commits, but the work's all good - all you need to do is recommit it differently.
# All your files are intact, but all the changes show up as changes to be committed with git status
alias grss='git reset --soft'
#alias gundos='git reset --soft HEAD^'  # Soft Undo your last commit
alias grs1='git reset HEAD -- '  # usage: guns filename, make this file from staged status to unstaged

#  ===============
#  = Git Rebase (grb) =
#  ===============
alias grb='git rebase -p'
alias grbthis='git rebase origin/$(git_current_branch)'
alias grbc='git rebase --continue'
alias grbs='git rebase --skip'
alias grbi='git rebase -i'
alias grba='git rebase --abort'

#  ===============
#  = Git Remote (gro) =
#  ===============
alias gro='git remote'
alias grov='git remote -v'
alias gros='git remote show'
alias groso='git remote show origin'
alias groa='git remote add' # ex: git remote add origin git@github.com:caius/foo.git
alias groao='git remote add origin'
alias gror='git remote rm'
alias groro='git remote rm origin' # ex: git remote rm origin

#  =============
#  = Git Show (gsh) =
#  =============
alias gsh='git show'  # git show HEAD@{5}

#  ==============
#  = Git Stash (gst) =
#  ==============
alias gst='git stash'
alias gsts='git stash save'  # add a custom stash message along with the stash. like gca
alias gstl='git stash list'    # To see which stashes you’ve stored
alias gstc='git stash clear'

# Creating a Branch from a Stash
# @syntax  branch <branchname> [<stash>]
alias gstb='git stash branch'    # creates a new branch for you, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully

alias gsta='git stash apply'    # reapply the stash you just stashed or If you don’t specify a stash, Git assumes the most recent stash
alias gssai='git stash apply --index'    # The changes to your files were reapplied, but the file you staged before wasn’t restaged, try to reapply the staged changes

alias gstp='git stash pop'

# apply the stash into the staging, then drop that stash, work like gssp
# @usage: gstd 2   //apply stash@{2} and drop it immediately
function gstd() {
	git stash apply "stash@{$1}" && git stash drop "stash@{$1}"
}

# --keep-index, all changes already added to the index are left intact.
#  --include-untracked option is used, all untracked files are also stashed and then cleaned up with git clean, leaving the working directory in a very clean state.
#  --all option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.
function gst1() {
	git add $1 && git stash --keep-index
}

# TODO: did not work
# Un-applying a Stash: if you don’t specify a stash, Git assumes the most recent stash
# un-apply those changes that originally came from the stash. Git does not provide such a stash unapply command, but it is possible to achieve the effect by simply retrieving the patch associated with a stash and applying it in reverse
# alias gsu='git stash show -p | git apply -R'
# need to verify, current did not work
function gssu() {
	git stash show -p "stash@{$1}" && git apply -R
}

# discard unstaged changes in git
# follow with 'git stash drop' to drop that stash
alias gstk='git stash save --keep-index'


#  ===========
#  = Git Tag (gt)=
#  ===========
alias gt='git tag'   # basic tag, can just pass the tag name after it
alias gta='git tag -a'  # create annotated tag. ex: git tag -a v1.4 -m 'my version 1.4'
# tag later ex:   git tag -a v1.2 -m 'version 1.2' 9fceb02

# git show v1.4  # Shows the tagger info, the date the commit was tagged, the annotation message before showing the commit info

alias gtl='git tag -l'  # take a tag name, search for tags with a particular pattern, ex: gtl 'v1.4.2.*'

alias gts='git tag -s' #signed tags with GPG, assuming you have a private key, use -s instead of -a. When run git show, you could see your GPG signature attached. When using git tag -v [tagName]. Need to have singer's public key in your keyring

alias gtv='git tag -v' # ex: gtv [tagName]


#  ==================
#  = Git Submodule (gsm) =
#  ==================
alias gsm='git submodule'

# add the repo to your project, possibly maintain your own changes to it, but continue to merge in upstream changes.
# ex:  git submodule add git://github.com/chneukirchen/rack.git rack
alias gsma='git submodule add'

# Cloning a Project with Submodules
# Here you’ll clone a project with a submodule in it. When you receive such a project, you get the directories that contain submodules, but none of the files yet: need to run `git submodule init`, then run `git submodule update`
alias gsmi='git submodule init'
alias gsmu='git submodule update'

# Note:  it checks out the specific version of the project, but not within a branch. This is called having a detached HEAD.  If you do an initial submodule update, commit in that submodule directory without creating a branch to work in, and then run git submodule update again from the superproject without committing in the meantime, Git will overwrite your changes without telling you. To avoid this issue, create a branch when you work in a submodule directory with git checkout -b work or something equivalent.

#  ===========
#  = Git Rm (grm) =
#  ===========
alias grm='git rm'

# Override the up-to-date check.
alias grmf='git rm --force'

# --cached, unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.
# To remove the file from the repo and not delete it from the local file system use:
alias grmc='git rm --cached'


# delete untracked and ignored files. It deletes files
# -n   saft preview    -d  delete directory    -f  force deleteion
# -x  delete files even if they are in .gitignore    -X  only delete in .gitignore file

# git clean -f //But beware... there's no going back. Use -n or --dry-run to preview the damage you'll do.
# If you want to also remove directories, run git clean -f -d
# If you just want to remove ignored files, run git clean -f -X
# If you want to remove ignored as well as non-ignored files, run git clean -f -x
alias gcn='git clean'

alias gcl='git clone'


alias gdt='git difftool'  # ex: git difftool branchName file.name

alias gm="git merge --no-ff"    #No fast forward
alias gmf="git merge --ff-only"   #Only fast forward
alias gmfthis='gmf origin/$(git_current_branch)'  #Fast forward merge with current brunch

alias gmt='git mergetool'  # ex: git mergetool

alias gfc='grep -r "<<<<" *'  # search for merge conflict markers

# count number of commits per commiter
alias gct='git shortlog -s -n --no-merges'

alias gdm='git diff master'
alias gd='git diff -M'
alias gdc='git diff --cached -M'
alias gnp="git-notpushed"



#  =====================
#  = Git Format-Patch (gph) =
#  =====================
#  Syntax: gph* [patch_file_name.patch]

# ex: git format-patch master --stdout > fix_empty_poster.patch
alias gph='git format-patch --stdout >'  # make a patch. stuff commits in a file and send them to someone to apply them.

# git apply --stat fix_empty_poster.patch
alias gphs='git apply --stat'  # does not apply the patch, but only shows you the stats about what it’ll do

# git apply --check fix_empty_poster.patch
alias gphc='git apply --check'  # Git allows you to test the patch before you actually apply it.

# git am --signoff < fix_empty_poster.patch
alias gpha='git am --signoff <' # use git am instead of git apply, git am allows you to sign off an applied patch, patches were applied cleanly and your branch should be updated. git log, you’ll find that the commit messages contain a “Signed-off-by” tag.

#  ===============
#  = Git Plugins = (read plugins/README.md for details)
#  ===============

# from plugins/git/git-wtf
# display the state of your repository in a readable and easy-to-scan format
alias gbst='~/bin/dotfiles/plugins/git/git-wtf'

# from plugins/git/git-publish-branch
# Useful if you publish your topic branches to the outside world.
alias gbpb='~/bin/dotfiles/plugins/git/git-publish-branch'

# from plugins/git/git-rank-contributors
# paws through your logs and ranks all the contributors by the size of their diffs.
alias ggcc='~/bin/dotfiles/plugins/git/git-rank-contributors -v'

# from plugins/git/git-show-merges
# shows you which branches have been merged in to the current branch, and which haven't. That's it. You can also specify multiple non-topic branches (merge branches?) on the commandline.
alias ggshm='~/bin/dotfiles/plugins/git/git-show-merges'

# from plugins/git/gbrt.rb
# Show each Git branches status sorted by time, use for merging and maintainance
alias gbs='ruby $HOME/bin/dotfiles/plugins/git/gbrt.rb'

# A very slightly quicker way to credit an author on the latest commit.
# $1 - The full name of the author.  $2 - The email address of the author.
# git credit "Zach Holman" zach@example.com
alias gcredit='git commit --amend --author "$1 <$2>" -C HEAD'

# Setup a tracking branch from [remote] [branch_name]
function gbt() {
	git branch --track $2 $1/$2 && git checkout $2
}
# Quickly clobber a file and checkout
function grf() {
	rm $1
	git checkout $1
}
#initialize a new git repo
#@param:  folder name
git-new() {
	[ -d "$1" ] || mkdir "$1" &&
	cd "$1" &&
	git init &&
	touch .gitignore &&
	git add .gitignore &&
	git commit -m "Added .gitignore."
}
# Internal Usage for current branch. Do not remove
git_current_branch() {
	cat "$(git rev-parse --git-dir 2>/dev/null)/HEAD" | sed -e 's/^.*refs\/heads\///'
}
# Call from inside an initialized Git repo, with the name of the repo.
function new-git() {
	ssh git@example.com "mkdir $1.git && cd $1.git && git --bare init"
	git remote add origin git@example.com:$1.git
	git push origin master
	git config branch.master.remote origin
	git config branch.master.merge refs/heads/master
	git config push.default current
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

#  =========
#  = Legit =  https://github.com/kennethreitz/legit
#  =========

# legit switch <branch>
# Switches to specified branch. Defaults to current branch. Automatically stashes and unstashes any changes.
# Ex: switch to destination branch, it will stash the current branch changes, and unstashes destination branch changes. When switch back, it will apply stashed to the current branch.
alias gco-='legit switch'

# legit publish <branch>
# Publishes specified branch to the remote.
alias gpub='legit publish'

# legit unpublish <branch>
# Removes specified branch from the remote.
alias gpub-='legit unpublish'

# legit sync [<branch>]
# it is happening on one single published branch. Quick pull/push task.
# Tasks:  1> switch to specific branch.   2> stash current staging  3> pulling commits from the server, Fetch, Auto-Merge/Rebase  4> pushing commits from server.  5> Unstash
# Syncronizes the given branch. Defaults to current branch. Stash, Fetch, Auto-Merge/Rebase, Push, and Unstash. You can only sync published branches.
alias gsync='legit sync'

# legit harvest [<src-branch>] <dest-branch>
# Auto-Merge/Rebase of specified branch changes into the second branch.
alias ggm='legit harvest'


# Super custom multiple branches merge/destory method based on Git-Flow idea
# auto merge/rebase the src-branch, finally, remove it at the last step
# Expect 3 arguments
# @usage: ggm- src-branch dest-branch dest-branch
# @output: src-branch will merge into two dest-branches, then destory the src-branch
function ggm-() {
	legit harvest $1 $2 && legit graft $1 $3
}

# Super custom fn will sync the src branch by using legit sync
# then will apply the merge into the destination branch
function ggsm {
	legit sync $1 && legit harvest $1 $2
}

#  ==============
#  = Git Extras =
#  = https://github.com/visionmedia/git-extras
#  ==============
alias ges='git-extras'

alias ggp='git gh-pages'  #Sets up the gh-pages branch. (See [GitHub Pages](http://pages.github.com/) documentation.)

alias ggc='git contrib'  #show a user's contribution  git-contrib <author>  ex:  git contrib visionmedia

alias ggs='git summary'  # ex:repository summary & contrib   ex: git summary

alias gge='git effort'  # ex:show effort statistics on file(s)   ex: git effort --above 15 {src,lib}/*  or <= Number

alias ggcs='git commits-since'  # ex: show commit logs since some date   ex: git commits-since yesterday

alias ggct='git count'  # ex: show commit count
alias ggca='git count --all'  # ex: show detailed commit count

alias ggr='git release'  # ex: commit, tag and push changes to the repository. Push the branch / tags with message "Release <tag>"

alias gig='git ignore'  # add .gitignore patterns, by default, it will show from .gitignore    ex: git ignore build "*.o" "*.log"

alias ggi='git info'  # show information about the repository    ex: git info

# git-graft <src-branch> [dest-branch]   ex: git graft new_feature_branch [dev]
# Merge commits from src-branch into dest-branch. (dest-branch defaults to master.) merge and then destroy a given branch
alias ggmd='git graft'

# git squash <src-branch> [msg]    ex: git squash fixed-cursor-styling "Fixed cursor styling"
#Merge commits from src-branch into the current branch as a single commit. This is useful when small individual commits within a topic branch are irrelevant and you want to consider the topic as a single change.
alias gsquash='git squash'

alias ggh='git changelog'  # History.md   file generation. changelog population
alias gghl='git changelog --list'  # History.md list commits

alias gundo='git undo'   # undo one or more of the latest commits  ex: git undo [3]

alias gn='git setup'   # set up a git repository with initial commit  ex: git-setup [dir]  if dir not exist, default to the current

alias ggt='git touch'  # create new file(s) and add file(s) to the index (git)  ex: git-touch [filename]

alias ggd='git obliterate'  # Completely remove a file from repo, including past commits & tags.  ex: git-obliterate [filename]

alias ggz='git archive-file'  # Creates an zip archive of the current git repository. The name of the archive will depend on the current HEAD of your git respository.

alias glc='git local-commits'  # List all commits on the local branch that have not yet been sent to origin. take gl flag

alias gbf='git feature'  # Create the given feature 'name' branch, then check it out   ex:  git feature dependencies
alias gbff='git feature finish'  # When finished, merge this feature branch into the current branch ( checked out)

alias gbr='git refactor'  # ex:  git refactor branchName
alias gbrf='git refactor finish'  # When finished, merge this refactor branch into the current branch ( checked out)

alias gbb='git bug'  # git bug branchName
alias gbbf='git bug finish'  # When finished, merge this bug branch into the current branch ( checked out)


# Ex: bitcl dotfiles  # git remote add origin ssh://git@bitbucket.org/mattma/dotfiles.git
function bbcl () {
	git clone ssh://git@bitbucket.org/mattma/$1.git
}

function bba () {
	git remote add origin ssh://git@bitbucket.org/mattma/$1.git
}

function ghcl () {
	git clone https://github.com/mattma/$1.git
}

function gha () {
	git remote add origin https://github.com/mattma/$1.git
}


#  ============
#  = Git_Scripts = https://github.com/jwiegley/git-scripts
#  ============

# git-addremove
# add untracked file on Staging, remove deleted files
# add/remove all changes from the index, similar to hg addremove
alias ggar='~/bin/dotfiles/plugins/git/git-scripts/git-addremove'

#alias gia='~/bin/dotfiles/plugins/git/git-scripts/git-all-commits'
#alias gia='ruby $HOME/bin/dotfiles/plugins/git/git-scripts/git-all.rb'

#  ===========================
#  = Super Awesome functions =
#  ===========================
#
# Zip the name of the folder in the same directory
function zip() {
	zip -r $1.zip $1
}

# Get gzipped file size
function gz() {
	echo "orig size (bytes): "
	cat "$1" | wc -c
	echo "gzipped size (bytes): "
	gzip -c "$1" | wc -c
}

# Create a data URL from an image (works for other file types too, if you tweak the Content-Type afterwards)
function dataurl() {
	echo "data:image/${1##*.};base64,$(openssl base64 -in "$1")" | tr -d '\n'
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	open "http://localhost:${port}/"
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
	encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Gzip-enabled `curl`
function gurl() {
	curl -sH "Accept-Encoding: gzip" "$@" | gunzip
}

# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}

# Find Image width
function width () {
	echo $(sips -g pixelWidth $1 | grep -oE "[[:digit:]]{1,}$")
}

# Find Image height
function height () {
	echo $(sips -g pixelHeight $1 | grep -oE "[[:digit:]]{1,}$")
}


#  ====================
#  = System Processes =
#  ====================
alias tu='top -o cpu' # cpu
alias tm='top -o vsize' # memory

# Empty the Trash on all mounted volumes and the main HDD. Also, clear Apple’s System Logs to improve shell startup speed
alias emptytrash="sudo rm -rfv /Volumes/*/.Trashes; sudo rm -rfv ~/.Trash; sudo rm -rfv /private/var/log/asl/*.asl"

# Recursively delete `.DS_Store` files
alias cleanup="find . -type f -name '*.DS_Store' -ls -delete"

# Trim new lines and copy to clipboard
alias tc="tr -d '\n' | pbcopy"

# File size
alias fs="stat -c \"%s bytes\""

# ROT13-encode text. Works for decoding, too! ;)
alias rot13='tr a-zA-Z n-za-mN-ZA-M'

# Show/hide hidden files in Finder
alias show="defaults write com.apple.Finder AppleShowAllFiles -bool true && killall Finder"
alias hide="defaults write com.apple.Finder AppleShowAllFiles -bool false && killall Finder"

# Show the path in the finder new window. One time edit
alias showPath="defaults write com.apple.finder _FXShowPosixPathInTitle -bool YES && killall Finder"

# Hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"

# URL-encode strings
alias urlencode='python -c "import sys, urllib as ul; print ul.quote_plus(sys.argv[1]);"'

# Disable Spotlight
alias spotoff="sudo mdutil -a -i off"
# Enable Spotlight
alias spoton="sudo mdutil -a -i on"

# PlistBuddy alias, because sometimes `defaults` just doesn’t cut it
alias plistbuddy="/usr/libexec/PlistBuddy"


# From http://github.com/suztomo/dotfiles
function rmf(){
	for file in $*
	do
		__rm_single_file $file
	done
}

function __rm_single_file(){
	if ! [ -d ~/.Trash/ ]
	then
		command /bin/mkdir ~/.Trash
	fi

	if ! [ $# -eq 1 ]
	then
		echo "__rm_single_file: 1 argument required but $# passed."
		exit
	fi

	if [ -e $1 ]
	then
		BASENAME=`basename $1`
		NAME=$BASENAME
		COUNT=0
		while [ -e ~/.Trash/$NAME ]
		do
			COUNT=$(($COUNT+1))
			NAME="$BASENAME.$COUNT"
		done

		command /bin/mv $1 ~/.Trash/$NAME
	else
		echo "No such file or directory: $file"
	fi
}


#  ==========
#  = SERVER =
#  ==========
function whoson () {
	date
	echo "Users logged in to $computer:"
	who
}

# Get OS X Software Updates, update Homebrew itself, and upgrade installed Homebrew packages
alias update='sudo softwareupdate -i -a; brew update; brew upgrade'

# IP addresses
alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="ipconfig getifaddr en1"
alias ips="ifconfig -a | grep -o 'inet6\? \(\([0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+\)\|[a-fA-F0-9:]\+\)' | sed -e 's/inet6* //'"

# Enhanced WHOIS lookups
alias whois="whois -h whois-servers.net"

# Flush Directory Service cache
alias flush="dscacheutil -flushcache"

# View HTTP traffic
alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""
